

*structs*
-------------------------
*epoll_event* 每一个成员的类型
   struct epoll_event {
       uint32_t     events;	 /* Epoll events */
       *epoll_data_t* data;	 /* User data variable */
   };
*epoll_data_t* 一个联合类型
   typedef union epoll_data {
       void	   *ptr;
       int	    fd;
       uint32_t     u32;
       uint64_t     u64;
   } epoll_data_t;

*create-epoll*
 得到一个epoll的fd (instance). 
 |epoll_create|(int size //这个参数已经不用了) since 2.6
 |epoll_create1|(int flag see man)

*epoll-limit* /proc/sys/fs/epoll/max_user_watches
  Because each file descriptor registered in an epoll interest list requires a small
  amount of *nonswappable* kernel memory, the kernel provides an interface that
  defines a limit on the total number of file descriptors that each user can register in
  all epoll interest lists. The value of this limit can be viewed and modified via
  max_user_watches, a Linux-specific file in the /proc/sys/fs/epoll directory. The default
  value of this limit is calculated based on available system memory 

epoll_wait
在内核准备好数据后返回。 Fin包也是普通数据, read return 0
RST ?


*events*
---------------------
*ET* 边沿触发 (需要使用EPOLLET 设置)
*LT* 水平触发 (默认的)

//see *epoll_ctl*
EPOLLIN
EPOLLPRI
EPOLLRDHUP
EPOLLOUT
EPOLLET
EPOLLONESHOT

EPOLLERR :这两个events epoll_wait 总是会监听，不需要在epoll_ctl 中设置
EPOLLHUP //对应fd有挂起事件 ,
          可能会在接受了RST 的socket上write时收到
         //子进程崩溃时 PIPE fd 的另一端会收到EPOLLHUP

//触发事件
1. EPOLLIN。
   1、listen fd，有新连接请求，触发
   2、对端发送普通数据，触发

2.EPOLLPRI
  1.带外数据，只触发EPOLLPRI。

3. EPOLLIN和EPOLLRDHUP
   对端正常关闭（程序里close()，shell下kill或ctr+c），
   触发，但是不触发EPOLLERR和EPOLLHUP。

4. EPOLLERR
	！！！！！！socket能检测到对方出错吗？目前为止，好像我还不知道如何检测。
	但是，在给已经关闭的socket写时，会发生EPOLLERR，也就是说，只有在采取行动（比如
	读一个已经关闭的socket，或者写一个已经关闭的socket）时候，才知道对方是否关闭了。
	这个时候，如果对方异常关闭了，则会出现EPOLLERR，出现Error把对方DEL掉，close就可以
	了。！！！！！！！

4、对端异常断开连接（只测了拔网线），没触发任何事件。
   所以server中检查超时很重要！！！！！！！！！！！！！！！！！！！！！！！


*epoll-op* 操作epoll都使用 |epoll_ctl| 函数， 不同的op参数代表不同的操作
------------------
  *add-fd*
  	*fd type* epoll_ctl 不支持一般文件和目录文件fd，???
        我使用一个文本文件的fd 都OK 没有报错??? 为啥？？？
        每一个evnets都是对应与一个fd的，所以不同fd可以设置不同的边沿触发和水平触发
  *delete-fd*
    传入须要删除的fd
    	E_TEST(-1, epoll_ctl(epoll_fd, EPOLL_CTL_DEL, e.data.fd, NULL/* ignore the arg */));
       
  *modify-fd*
    传入须要删除的fd,和新的epoll_event
	    e.events |= EPOLLET;
	    E_TEST(-1, epoll_ctl(epoll_fd, EPOLL_CTL_MOD, e.data.fd, &e));

*poll-readly-fd*
-------------------------------
  得到指定events Readly的fd。 
 |epoll_wait|(epollfd, 返回直的数组，数组的元素个数，超时时间)
 返回有几个readly的fd 
  返回的fd的空间需要调用这创建，传递给|epoll_wait|
  返回的每个epoll_event 中 events 是触发readly的event，data和epoll_ctl是的一样

*copy-epoll-fd*
-------------------------------
使用dup来复制epoll的fd，不会导致kernel复制event-list，kernl会为epoll生成一个inode
vim:ft=help
