

*structs*
-------------------------
*epoll_event* 每一个成员的类型
   struct epoll_event {
       uint32_t     events;	 /* Epoll events */
       *epoll_data_t* data;	 /* User data variable */
   };
*epoll_data_t* 一个联合类型
   typedef union epoll_data {
       void	   *ptr;
       int	    fd;
       uint32_t     u32;
       uint64_t     u64;
   } epoll_data_t;

*create-epoll*
 得到一个epoll的fd (instance). 
 |epoll_create|(int size //这个参数已经不用了) since 2.6
 |epoll_create1|(int flag see man)

*epoll-limit* /proc/sys/fs/epoll/max_user_watches
  Because each file descriptor registered in an epoll interest list requires a small
  amount of *nonswappable* kernel memory, the kernel provides an interface that
  defines a limit on the total number of file descriptors that each user can register in
  all epoll interest lists. The value of this limit can be viewed and modified via
  max_user_watches, a Linux-specific file in the /proc/sys/fs/epoll directory. The default
  value of this limit is calculated based on available system memory 

epoll_wait
在内核准备好数据后返回。 Fin包也是普通数据, read return 0
RST ?


*events*
---------------------
*ET* 边沿触发 (需要使用EPOLLET 设置)
*LT* 水平触发 (默认的)

EPOLLIN
EPOLLPRI
EPOLLRDHUP
EPOLLOUT
EPOLLET
EPOLLONESHOT

EPOLLERR :这两个events epoll_wait 总是会监听，不需要在epoll_ctl 中设置
EPOLLHUP

|epoll_ctl|
*epoll-op* 操作epoll都使用 函数， 不同的op参数代表不同的操作
------------------
  *add-fd*
  	*fd type* epoll_ctl 不支持一般文件和目录文件fd，???
        我使用一个文本文件的fd 都OK 没有报错??? 为啥？？？
        每一个evnets都是对应与一个fd的，所以不同fd可以设置不同的边沿触发和水平触发
  *delete-fd*
    传入须要删除的fd
    	E_TEST(-1, epoll_ctl(epoll_fd, EPOLL_CTL_DEL, e.data.fd, NULL/* ignore the arg */));
       
  *modify-fd*
    传入须要删除的fd,和新的epoll_event
	    e.events |= EPOLLET;
	    E_TEST(-1, epoll_ctl(epoll_fd, EPOLL_CTL_MOD, e.data.fd, &e));

*poll-readly-fd*
-------------------------------
  得到指定events Readly的fd。 
 |epoll_wait|(epollfd, 返回直的数组，数组的元素个数，超时时间)
 返回有几个readly的fd 
  返回的fd的空间需要调用这创建，传递给|epoll_wait|
  返回的每个epoll_event 中 events 是触发readly的event，data和epoll_ctl是的一样

*copy-epoll-fd*
-------------------------------
使用dup来复制epoll的fd，不会导致kernel复制event-list，kernl会为epoll生成一个inode
vim:ft=help
