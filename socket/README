
Qus.
1. TCP 不断接收包，但是一直不读取，
      这些包满了后会被丢弃吗？
      write的时候会因为read buf已满出错吗？

TCP 连接关闭情况

1.正常关闭 A: close. 给B发送 FIN包
  B: 调用read 返回0. 表示A：已经关闭（不能在发送数据了)但是还可以接受数据
  Qus. 如果B不掉用 read可以知道A：发送的FIN吗？

2.server段程序崩溃。system 会发送FIN 包
   client 段也许会知道(操作系统为打开的fd调用了close）
                      也可能不会知道,两中情况
    另一端会立即知道
    TEST
    B： 调用read的会收到 EOF,或一直阻塞
    C:  调用write ok, 在read时会收到RST, 收到RST后内核会断开TCP链接
        如果忽略RST 错误，再次调用write 会收到SIGPIPE.

3. server 主机崩溃 不会发送FIN 包
    另一不会收到任何信息，在主机重启之前这种情况看起了和网络故障
    一样, write 发送的msg都会tiemout 返回ETIMEDOUT
   

4. server主机崩溃并重启
     server会收到一个client的重传data，而
     server不知如何处理他，server会给client发送一条RST，并断开链接
     client 收到一个RST后会丢弃链接
 A:调用read时server以重启: 
       client read返回EOF或其他错误
 B:调用write时server以重启: SIGPIPE

3. A突然断电，网线断掉：
   所有操作都阻塞，或超时


Socket API 注意是不是可重入的

|socket|/3
  不是每个参数都可以相互匹配
  3个参数有有效的匹配
  

|connect| 调用发起3次握手，知道连接建立或者失败才返回
收到第二分解 peer SYN(ACK)包. 返回
如果connect 失败则socket 不可再用。必须关闭. TCP
因为connect failed 后 socket的状态为定义

返回失败的几种情况:
1. 对方没有开机: 对方太忙，
  始终没有收到对方的ACK，则返回ETIMEDOUT

2. Peer 对应服务没有启动。 连接端口没有监听进程
  Peer 回复 RST connect 返回 ECONNREFUSED

3. 路由不可达

4. 对方主机可链接数量满了,返回ECONNREFUSED

|bind| 绑定socket到一个协议地址

如果不帮定。那么在connect 或 listen 时，内核就要为socket
选择一个临时*port* *IP* 对于client bind无所谓。但是对用
server 通常都需要一个固定的port

IPaddrs: 进程绑定的ip地址必须是进程所在主机的一个接口
绑定IP后, 进程所有发送的包的源地址IP就是绑定的IP.
进程只能接受目的地址是绑定IP的包

如果TCP server不绑定IP，则Server的IP会是 client SYN包的目的IP

IP: 统配地址 ipv4 INADDR_ANY, 内核指定, 何时指定？
             ipv6 in6addr_any. 
通配符不同的原因:
    INADDR_ANY 通常是0.可以使用一个数字表示
    ipV6 地址是个结构，不能使用0来表示 port： 0, 内核指定 目的IP 和 到达接口
如何一个主机有多个IP地址。情况是什么?

得到connect后内核分配的地址
getsockname  //通常client调用，得到自己的
getpeerkname //通常server调用，得到client的

|listen/2|
做两件事
1.把fd从主动接口，设置为被动接口.监听状态 
  当主机收到一个链接请求时，kernel就会查找监听socket列表
  socket/3默认返回一个主动接口
  指示内核因该接受指向此接口的连接请求.
  TCP 状态从 CLOSED 到 LISTEN
2.设置请求队列大小
  The  behavior of the backlog argument on TCP sockets changed with Linux
  2.2.  Now it specifies the  queue  length  for  completely  established
  sockets	waiting  to  be  accepted, instead of the number of incomplete
  connection requests.  The maximum length of the	queue  for  incomplete
  sockets	can be set using /proc/sys/net/ipv4/tcp_max_syn_backlog.  When
  syncookies are enabled there is no logical maximum length and this set‐
  ting is ignored.  See tcp(7) for more information.
  more see *listen(3)*

3. backlog 参数的含义:
       从linux2.2 开始， backlog定义为:
        已经完成链接但还未accepted的 sockets 等待队列大小
        backlog 最大不会大于 /proc/sys/net/core/somaxconn 
        需要修改somaxconn 

4. 未完成的链接队列的大小由 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定


|accept|
Qus. 返回的socket的源地址和目的地址于listen的有何不同


EPIPE:
写一个已经收到FIN包的接口是ok的。
但是写一个已经收到RST的接口就引发SIGPIPE

ip<->name
|gethostbyname|
|gethostbyaddr|
不可重入

使用这些函数主机要联网
使用2_r version

通过 /etc/resolv.conf 文件来查询
如果查询不到，则通过UDP相服务器查询
不通过DNS，也可在 /etc/hosts(静态主机文件)中查找

|gethostname|
return same as hostname(1)
不可重入

|getaddrinfo|
比gethostbyname 更高级的函数
屏蔽了相关协议，
|freeaddrinfo|
不可重入

port<->service-name
|getservbyname|
|gettservbport|
通过 /etc/service 文件查询


|getprotobynumber|

EE 健壮SOCKET 程序需要注意的几点
  0. 检查系统调用返回值
  1. 捕捉信号：
     +. SIGPIPE. 
        给一个对方已经关闭的socket写数据时产生
          通常做忽略处理.
     +. SIGURG
        紧急IO处理，外带数据OOB到来时产生
          可以log出来
     +. SIGCHLD
        多进程模式下，通常检测SIGCHLD来wait结束的进程
             while(waitpid(-1,0,WNOHANG) > 0);
     +. SIGHUP
         在守护进程模式下，通常使用SIGHUP信号来让程序restart
     +. SIGIO
         ???
     +. SIGALRM
          需要时处理
   
    2. 资源管理
        CPU memory Processes
           


|setsockopt| more see *tcp(7)*
几种常见的选项
1. SO_KEEPALIVE 
  保活心跳

2. SO_RCVBUF, SO_SNDBUF
  接收发送缓存大小，tcp窗口的小
  必须在connect bind前调用
  linux  SO_RCVBUF=87380, SO_SNDBUF=16384
  
  每个TCP链接都维护一个接收窗口和发送窗口
  窗口主要用于流量控制，和超时重传

  receive winodw
  +----+----+----+----+----+
  | 14 | 15 | 16 | 17 | 18 |
  +----+----+----+----+----+
  左边是期望收到的下一个segment的序号，右边是可以接受的最大的segment的序号，
  tcp 只会接收在窗口中的segment，也就是说 不再receive-winodw 序号中的segment都将被抛弃


  send window
  +----+----+----+----+----+
  | 14 | 15 | 16 | 17 | 18 |
  +----+----+----+----+----+
                 ^
                 |
       next-send/
  send-window 有已发送还被确认的segment和可以发送还没发送的segment组成

  Qus. TCP 何时通知应用层有数据到了??
  TCP 是一种流协议：
       没有固定报文边界的协议，读取TCP数据就向从串口读数据一样，
       无法预先得知在一次读取时会返回多少字节
  send 默认情况下应用层调用send, send在把数据复制到内核TCP栈后就返回了，至于
       何时发送，是不是会和其他send的数据合并成一个pkg发送，都是有内核决定的
       也就是说，tcp实际发送的包和调用send的时候的数据基本上没有直接关系.
       而且读取时也无法判断数据是一次到来的，还是多次到来的.
       所以，不要对read时的数据有任何的假设, 对应用层来说TCP没有分组的概念


3. SO_RCVTIMEO SO_SNDTIMEO
  接收发送超时设置. default is 0

4. SO_REUSEADDR SO_REUSEPORT
   bind 之前设置
  允许重用地址， 在time_wait 状态下的地址是否可以重用
   一般用于重启后马上要重新绑定到原来地址的
   使用SO_REUSEADDR 的不足是他允许你有可能两个进行绑定同一个
   地址??? 不可能吧，操作系统不允许这样，哪步会返回错误呢？

5. TCP_NODELAY
   禁止Nagle算法
   不会把小包拼接成大包后在发送，会使得小包用户的体验增强

6. TCP_DEFER_ACCEPT
   当连接请求由数据到达是在返回。 用于拒绝接收只建立连接不发送数据的请求。
   
7. SO_LINGER
   用于区分，正常关闭和异常关闭
   改变 close 的默认动作，通常close立即返回。如果close时还有没有发出的msg
   系统将试着把这些msg发出
   传递参数 linger { int l_onoff /*0 is off*/
                     int l_linger 
                    }
  l_onoff = 0 等于没有设置,close 默认动作
  l_onoff != 0 ??? linux 

|write|| |send/4| 
send 和write的前3个参数相同，但是有一个flags 参数
 send 只有在socket是链接状态下,才能调用
 write(socket, buf, len) == send(socket, buf, len, 0)
 flags:
     MSG_OOB 外带数据

|sendto|/6
  一般用于UDP ,TCP也可以用
  send(socket,buf,len,flags) = sendto(socket,buf,len,flags, NULL, 0)
  if sendto用于面向链接的 socket, (SOCK_STREAM, SOCK_SEQPACKET)
   后两个参数将被忽略, 这时后面两个参数必须为NULL，0，否则会返回
   错误 EISCONN

|recvfrom|
  用于UDP 接受

|inet_addr|
   x.x.x. 转化为二进制地址
  e.g. sockaddr_in addr.sin_addr.s_addr = inet_addr(x.x.x.)
 e.g.

brocdcase
 +. 有限广播地址
   255.255.255.255 路由不会转发此地址的msg，也就是说这个msg不会跑的子网
   以外的地方。 主要用来得到自己的IP
 +. 网络广播
   向一个指定网络的所有主机广播msg
   保留网络地址，主机地址全部为255
     e.g. 190.25.255.255 广播个190.25 网络中的所有主机
    路由不一定支持^_^
 +.
     
EE SYN Flood 攻击
 原理。。。。
 预防
 |syncookies| SYN Cookie
  一种预防SYN Flood 的方法 see .syncookie.readme
   

EE 网络内核参数 files
  /proc/sys/net/core/somaxconn 已经完成链接还没有accept的socket队列大小
        listen()的默认参数,挂起请求的最大数量.默认是128.对繁忙的服务器,增加该值有助于网络性能.
        可通过/etc/sysctl.conf 中添加net.core.somaxconn = 2048 来修改
        在执行 sysctl -p
  /etc/sysctl.conf
	# /etc/sysctl.conf - Configuration file for setting system variables
	# See /etc/sysctl.d/ for additional system variables
	# See sysctl.conf (5) for information.

 /proc/sys/net/core/wmem_max
   最大socket写buffer,可参考的优化值:873200
 /proc/sys/net/core/rmem_max
   最大socket读buffer,可参考的优化值:873200
 /proc/sys/net/ipv4/tcp_wmem
  TCP写buffer,可参考的优化值: 8192 436600 873200
 /proc/sys/net/ipv4/tcp_rmem
  TCP读buffer,可参考的优化值: 32768 436600 873200

 /proc/sys/net/ipv4/tcp_mem
	同样有3个值,意思是:
	net.ipv4.tcp_mem[0]:低于此值,TCP没有内存压力.
	net.ipv4.tcp_mem[1]:在此值下,进入内存压力阶段.
	net.ipv4.tcp_mem[2]:高于此值,TCP拒绝分配socket.
	上述内存单位是页,而不是字节.可参考的优化值是:786432 1048576 1572864

 /proc/sys/net/core/netdev_max_backlog
   进入包的最大设备队列.默认是300,对重负载服务器而言,该值太低,可调整到1000.
 /proc/sys/net/core/optmem_max
  socket buffer的最大初始化值,

 /proc/sys/net/ipv4/tcp_max_syn_backlog
   进入SYN包的最大请求队列.默认1024.对重负载服务器,增加该值显然有好处.可调整到2048.
 /proc/sys/net/ipv4/tcp_retries2
   TCP失败重传次数,默认值15,意味着重传15次才彻底放弃.可减少到5,以尽早释放内核资源.

 /proc/sys/net/ipv4/tcp_keepalive_time
 /proc/sys/net/ipv4/tcp_keepalive_intvl
 /proc/sys/net/ipv4/tcp_keepalive_probes
	这3个参数与TCP KeepAlive有关.默认值是:
	tcp_keepalive_time = 7200 seconds (2 hours)
	tcp_keepalive_probes = 9
	tcp_keepalive_intvl = 75 seconds
	意思是如果某个TCP连接在idle 2个小时后,内核才发起probe.如果probe 9次(每次75秒)不成功,
                      内核才彻底放弃,认为该连接已失效.对服务器而言,显然上述值太大. 可调整到:
	/proc/sys/net/ipv4/tcp_keepalive_time 1800
	/proc/sys/net/ipv4/tcp_keepalive_intvl 30
	/proc/sys/net/ipv4/tcp_keepalive_probes 3

  /proc/sys/net/ipv4/ip_local_port_range
  指定端口范围的一个配置,默认是32768 61000,已够大.

  net.ipv4.tcp_syncookies = 1
     表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；
  net.ipv4.tcp_tw_reuse = 1
     表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
  net.ipv4.tcp_tw_recycle = 1
     表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。
  net.ipv4.tcp_fin_timeout = 30
     表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。
  net.ipv4.tcp_keepalive_time = 1200
     表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。
  net.ipv4.ip_local_port_range = 1024 65000
     表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。
  net.ipv4.tcp_max_syn_backlog = 8192
     表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。
  net.ipv4.tcp_max_tw_buckets = 5000
     表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。默认为180000，改为 5000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于Squid，效果却不大。此项参数可以控制TIME_WAIT套接字的最大数量，避免Squid服务器被大量的TIME_WAIT套接字拖死。
  
vim: ft=help
