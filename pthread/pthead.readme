 vim: ft=markdown   

Qus.
1. 主线程如何等待所有的子线程，而不是某一个(pthread-join) ??

2. 如果一个线程crash了会影响别的线程吗？

3. 同一个process生成的线程，调用getpid 相同吗? 
        相同。

4. 主线程getpid 返回的值和自己的pthread id相同吗？
       不相同。pid
       gettid()  returns  the  caller's  thread  ID (TID).  
       In a single-threaded process, the thread ID is equal to the 
       process ID (PID, as returned by getpid(2)).  In a multi‐threaded process, 
       all threads have the same PID, but each one has a unique TID.

5. gettid 和 pthread-self 返回的值相同吗?
       不相同， gettid 返回的值时linux kernel 对一个线程的标记
       而pthread-self 时 pthread 线程库对一个线程的标记

EE 最佳实践
不要对新产生的线程的执行顺序有任何的假设

EE gettid
glibc 不提供gettid 要使用syscall 调用


EE
////线程不会共享局部变量,因为这些局部变量都是在调用
//堆上的，每个线程有自己的调用堆栈
所以不需要使用锁

EE 首先需要安装lib
compile and link command
`cc -D_REENTRANT file -pthread`

EE wait 的宏解析
W 表示wait
WNOHANG: w-no-hang //return immedatle if no child has exited


wait he waitpid (status )返回状态解析宏
WIFEXITED w-if-exited
正常终止 返回true，可用WEXITSTATUS取出推出参数

WIFSIGNALED w-if-signaled
异常终止返回真, 可用WTERMSIG取出使进程异常终止的

WIFSTOPPED w-if-stopped
WIFCONTINUED w-if-contionued

pthread
NTPL, 使用top查看新建的线程时PID显示的各自不同，但是用getpid，得到的pid数是
一样的，为啥？？？

EE pthread 的错误处理，不通过设置errno，来表示错误，对用pthread函数，如果返回
非0，就是出错，返回值就是错误吗，使用strerrno来显示

EE 共享内容
  1. 进程地址空间
  2. 文件描述符

EE **主线程的特殊性**
1. 线程的参数不同。 主线程使用crt0.o文件初始化.
2. 主线程结束时，不会等待其他线程。也就是说只用主线程终结，其他线程也会被终结
3. 如何不想这样，可以使用`pthread_exit`如不是从main 中 return
4. 在大多数系统上主线程运行在默认对在

EE **线程蒸发**

EE **线程分离**（回收）
在一个线程结束时，如果没有被分离，就会保留其虚拟内存，stack和其他系统资源。
分离线程意味着通知系统不再需要此线程。系统将回收分配给他的资源。 和父进程等待子进程类似.


EE 线程类`pthread_t`型

EE `pthread_create` 建立一个线程
EE `pthread_exit` 终止一个线程
EE `pthread_self` 得到自己的线程ID,所以的线程操作都需要线程ID

EE `pthread_equal` 判断两个线程是否相同

EE `pthread_detach` 分离一个线程
EE `pthread_join` 调用者会被阻塞直到指定线程终止。指定的线程会自动分离
  当join返回时，指定的函数已经被分离。：

EE 线程的创建
   1.主线程随进程的创建而创建。
   2.其他线程可以通过`pthread_create`创建
   3.接受到`SIGEV_THREAD`时也会创建一个线程

EE 线程创建后就会在就绪态。**进程到用的无序性** _从pthread-create返回与调用新的线程之间不存在同步关系_
EE 线程终止
  1. 线程通常从启动函数返中返回来终止自己
  2.`ptherad_exit`
  3.`ptherad_cancel` 调用`ptherad_canceld`返回码总是`PTHREAD_CANCELLED`
  如果线程已经分离则会立即进入回收状态,否则就会出现僵尸线程.(注意线程和进程的相似性,linux下线程其实就是进程)

EE 系统资源（malloc,mmap) _可以在任何时候由任何线程释放_. 
   信号量，互斥量,条件变量,信号灯可以由任何线程销毁. 前提没被解锁或现成等待. _但是有只有互斥量的主人才能释放解锁,所以线程终止时一定要解锁_


EE pthread-once(once-vaulable, once-routine)
   用于希望只被执行1次的代码段
   参数是一个标记变量 和一段执行过程

